# Модуль подключения к очкам

## Обзор основных классов модуля `app`
* **`MainActivity`** — активность и UI: инициализирует `BleManager`/`BleLogger`, подписывается на логи, вешает обработчики на кнопки «Scan/Connect/Bond/Disconnect», проверяет права/настройки перед сканом и отображает выбранное устройство, RSSI и текущее состояние машины состояний.
* **`BleManager`** — централизует логику подключения: хранит выбранное устройство и причину выбора, управляет сканом, подключением, включением уведомлений, отправкой стартовой команды и обработкой таймаутов/повторов, реагирует на события GATT и систему привязки (bonding), обновляя `BleState` и уведомляя слушателей.
* **`BleScanner`** — отвечает за поиск очков: запускает скан без фильтров, логирует «громкие» объявления, выбирает лучшего кандидата по RSSI среди результатов, совпадающих с жёстко заданным MAC (`KNOWN_MAC`) или с manufacturer‑payload от производителя Hubei (ID `0x02E1` и валидный формат длины). После дебаунса передает выбранный `ScanResult` и причину обратно в `BleManager`.
* **`BleProtocol`** — тонкий слой над выбранными характеристиками GATT: хранит ссылки на notify/write, логирует исходящие кадры и делегирует запись `BleManager` с нужным типом write.
* **`BleLogger`** — буферизирует последние логи, транслирует их в Logcat и подписчикам UI, добавляя метки времени/уровня.
* **`BleState` / `BleErrorReason`** — описывают конечный автомат соединения и основные ошибки (таймауты скана/подключения/дискавери, проблемы рукопожатия и бондинга).
* **Утилиты**: `BluetoothUtils` проверяет поддержку/включенность BLE, геолокацию и позволяет сбрасывать GATT‑кэш; `PermissionUtils` запрашивает нужные разрешения; `HexUtils` форматирует байты в hex для логов.

## Как выбираются очки при сканировании
1. `BleManager.startScan()` сбрасывает состояние, создаёт `BleScanner` и запускает скан на 25 секунд с таймаутом; при выборе кандидата сохраняет его MAC/RSSI/причину и переводит состояние в `DEVICE_FOUND`.
2. `BleScanner` анализирует каждое объявление: логирует «громкие» кадры (RSSI выше порога), проверяет `isMyvuCandidate`. Подходящим считается либо точное совпадение с `KNOWN_MAC = "2C:6F:4E:00:DC:B1"`, либо кадр с manufacturer ID `0x02E1`, у которого первый байт совпадает с длиной остального payload (формат Hubei).
3. Среди подходящих устройств выбирается наилучший по RSSI; выбор дебаунсится на 2 секунды, после чего скан останавливается и `BleManager` получает выбранный `ScanResult` с причиной (`MAC_OVERRIDE` или `HUBEI_MANUFACTURER`). При отсутствии кандидатов по таймауту сканер вызывает `onTimeout`, а менеджер ставит ошибку `NO_MATCHING_ADVERTISING`.

## Дальнейшая работа после выбора устройства
* Пользователь жмёт «Connect», `BleManager.connectToTarget()` подключается к выбранному MAC, заводит таймауты и регистрирует слушатель бондинга.
* После подключения выполняется discovery, включение нотификаций на нужных характеристиках, запись стартовой команды и ожидание первого notify; успешный notify переводит состояние в `HANDSHAKE_DONE` и ожидание системной пары.
* Запрос бондинга (`requestBond`) инициирует системную привязку; широковещательный ресивер отслеживает успех/неудачу и переводит состояния в `BONDED` или `ERROR`.
